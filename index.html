<!DOCTYPE html>
<html>
<head>
    <title>Cube Defense</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
        #shop {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            color: white;
            display: none;
            text-align: center;
        }
        #leaderboard {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
        }
        #pauseButton {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Health: <span id="health">100</span></div>
        <div>Coins: <span id="coins">0</span></div>
        <div>Kills: <span id="kills">0</span></div>
        <div>Wave: <span id="wave">1</span></div>
        <div>Special: <span id="special">Ready (Q)</span></div>
    </div>
    <div id="shop">
        <h3>Shop</h3>
        <button onclick="buyUpgrade('armor')">Armor (50 coins)</button>
        <button onclick="buyUpgrade('health')">Health (30 coins)</button>
        <button onclick="buyUpgrade('speed')">Speed (40 coins)</button>
        <button onclick="buyUpgrade('weapon')">Weapon (60 coins)</button>
        <button onclick="buyUpgrade('ally')">Ally Cube (10 coins)</button>
    </div>
    <div id="pauseMenu">
        <h2>Paused</h2>
        <button onclick="resumeGame()">Resume</button>
    </div>
    <div id="leaderboard">
        <h3>Top Scores</h3>
        <ol id="leaderboardList"></ol>
    </div>
    <button id="pauseButton" onclick="togglePause()">Pause</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Player setup
        const playerGroup = new THREE.Group();
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00,
            shininess: 100,
            specular: 0xffffff
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        const swordGeometry = new THREE.BoxGeometry(0.2, 0.2, 2.5);
        const swordMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xaaaaaa,
            shininess: 50,
            specular: 0xffffff
        });
        const sword = new THREE.Mesh(swordGeometry, swordMaterial);
        sword.position.set(0.6, 0, 0.5);
        playerGroup.add(player, sword);
        scene.add(playerGroup);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Sky
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        const cloudGeometry = new THREE.SphereGeometry(2, 16, 16);
        const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        for (let i = 0; i < 5; i++) {
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(
                (Math.random() - 0.5) * 40,
                15 + Math.random() * 5,
                (Math.random() - 0.5) * 20
            );
            cloud.scale.set(1 + Math.random(), 0.5 + Math.random() * 0.5, 1 + Math.random());
            scene.add(cloud);
        }

        // Grass ground
        const groundGeometry = new THREE.PlaneGeometry(50, 30);
        const groundTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAABJUlEQVR4nO2USwrCMBCEJ1EQRMTu1u6+gbfoFbyA4M5O3iM4Ozu7u7s7OwWPh8nMzL/fzH4M4MwwjBOCcT4H3sDvgFvgJngL3mFZGZZlYRhWlmXhDHgJjoE34C14C96C9+Ad+AB+BR/BZ/BZfAYfw+fwBXwJX8NX8A18A9/AV/ANfAvfwvfwPXwP34MP4Af4EX4CH8Fn8AV8CV/Cl/AlfAvfwvfwPXwPP4Af4Ef4CX8Cn8AV8CV/Cl/AlfAvfwvfwPXwPP4Af4Ef4CX8Cn8AV8CV/Cl/AlfAvfwvfwPXwPP4Af4Ef4CX8Cn8AV8CV/Cl/AlfAvfwvfwPXwPP4Af4Ef4CX8Cn8AV8CV/Cl/AlfAvfwvfwPXwPP4Af4Ef4CX8Cn8AV8CV/Cl/AFHUnB8xK/qoAAAAASUVORK5CYII=');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(10, 10);
        const groundMaterial = new THREE.MeshPhongMaterial({ map: groundTexture, color: 0x00cc00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let playerStats = {
            health: 100,
            maxHealth: 100,
            coins: 0,
            kills: 0,
            baseSpeed: 0.15,
            speed: 0.15,
            damage: 1,
            armor: 0,
            attackCooldown: 0,
            specialCooldown: 0,
            specialActive: false,
            specialTimer: 0,
            stunTimer: 0,
            speedTimer: 0,
            armorTimer: 0,
            weaponTimer: 0
        };

        let enemies = [];
        let portals = [];
        let allies = [];
        let trailParticles = [];
        let armorBubbles = [];
        const keys = {};
        let isPaused = false;
        let wave = 1;
        let waveTimer = 0;
        let enemiesToSpawn = 0;

        let leaderboard = JSON.parse(localStorage.getItem('cubeDefenseLeaderboard')) || [];
        updateLeaderboardUI();

        function resetGame() {
            saveScore(playerStats.kills);
            playerStats.health = playerStats.maxHealth;
            playerStats.stunTimer = 0;
            playerStats.coins = 0;
            playerStats.kills = 0;
            wave = 1;
            playerGroup.position.set(0, 0.5, 0);
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            portals.forEach(portal => scene.remove(portal));
            portals = [];
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            trailParticles.forEach(p => scene.remove(p));
            trailParticles = [];
            armorBubbles.forEach(b => scene.remove(b));
            armorBubbles = [];
            createPortal();
            createPortal();
            updateUI();
            spawnWave();
        }

        function createPortal() {
            const portalGeometry = new THREE.CylinderGeometry(2, 2, 0.2, 32);
            const portalMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 30 });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(
                (Math.random() - 0.5) * 45,
                0.1,
                (Math.random() - 0.5) * 25
            );
            scene.add(portal);
            portals.push(portal);
        }

        function spawnEnemy(type = 'normal') {
            if (portals.length === 0) return;
            const portal = portals[Math.floor(Math.random() * portals.length)];
            
            let size, color, hits;
            if (type === 'strong') {
                size = 1.5;
                color = 0x0000ff;
                hits = 10;
            } else if (type === 'boss') {
                size = 2;
                color = 0x800080;
                hits = 25;
            } else {
                size = 1;
                color = 0xff0000;
                hits = 1;
            }

            const enemyGeometry = new THREE.BoxGeometry(size, size, size);
            const enemyMaterial = new THREE.MeshPhongMaterial({ 
                color,
                shininess: 100,
                specular: 0xffffff
            });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.hitsRemaining = hits;
            enemy.position.copy(portal.position);
            enemy.position.y = size / 2;

            if (type === 'boss') {
                const crownGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
                const crownMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 50 });
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.y = size / 2 + 0.15;
                enemy.add(crown);
            }

            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnAlly() {
            const allyGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const allyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0000ff,
                shininess: 100,
                specular: 0xffffff
            });
            const ally = new THREE.Mesh(allyGeometry, allyMaterial);
            ally.position.copy(playerGroup.position);
            ally.timer = 7;
            scene.add(ally);
            allies.push(ally);
        }

        function createTrailParticle() {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.copy(playerGroup.position);
            particle.position.y = 0.5;
            scene.add(particle);
            trailParticles.push({ mesh: particle, life: 0.5 });
        }

        function createArmorBubble() {
            const bubbleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const bubbleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.5,
                shininess: 50
            });
            const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
            scene.add(bubble);
            armorBubbles.push(bubble);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') togglePause();
            if (e.key === 'q' && playerStats.specialCooldown <= 0) activateSpecial();
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseMenu').style.display = isPaused ? 'block' : 'none';
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
        }

        function activateSpecial() {
            playerStats.specialActive = true;
            playerStats.specialTimer = 4;
            playerStats.specialCooldown = 20;
            updateUI();
        }

        function updatePlayer() {
            if (isPaused || playerStats.stunTimer > 0) return;

            camera.position.set(playerGroup.position.x, 10, playerGroup.position.z + 15);
            camera.lookAt(playerGroup.position);

            let currentSpeed = playerStats.specialActive ? playerStats.baseSpeed * 2 : playerStats.speed;
            if (keys['ArrowUp']) playerGroup.position.z -= currentSpeed;
            if (keys['ArrowDown']) playerGroup.position.z += currentSpeed;
            if (keys['ArrowLeft']) playerGroup.position.x -= currentSpeed;
            if (keys['ArrowRight']) playerGroup.position.x += currentSpeed;

            playerGroup.position.x = Math.max(-24, Math.min(24, playerGroup.position.x));
            playerGroup.position.z = Math.max(-14, Math.min(14, playerGroup.position.z));

            if (keys[' '] && playerStats.attackCooldown <= 0) {
                attack();
                playerStats.attackCooldown = 0.5;
                sword.rotation.x = Math.PI / 4;
            }
            sword.rotation.x *= 0.9;

            playerStats.attackCooldown -= 0.016;
            playerStats.speedTimer = Math.max(0, playerStats.speedTimer - 0.016);
            playerStats.armorTimer = Math.max(0, playerStats.armorTimer - 0.016);
            playerStats.weaponTimer = Math.max(0, playerStats.weaponTimer - 0.016);
            if (playerStats.speedTimer > 0) {
                playerStats.speed = playerStats.baseSpeed * 2;
                if (Math.random() < 0.3) createTrailParticle();
            } else {
                playerStats.speed = playerStats.baseSpeed;
            }
            if (playerStats.armorTimer <= 0 && armorBubbles.length > 0) {
                armorBubbles.forEach(b => scene.remove(b));
                armorBubbles = [];
            }
            if (playerStats.specialActive) {
                playerStats.specialTimer -= 0.016;
                if (playerStats.specialTimer <= 0) playerStats.specialActive = false;
            }
            playerStats.specialCooldown -= 0.016;
            playerStats.stunTimer = Math.max(0, playerStats.stunTimer - 0.016);

            for (let i = trailParticles.length - 1; i >= 0; i--) {
                trailParticles[i].life -= 0.016;
                trailParticles[i].mesh.scale.multiplyScalar(0.95);
                if (trailParticles[i].life <= 0) {
                    scene.remove(trailParticles[i].mesh);
                    trailParticles.splice(i, 1);
                }
            }

            armorBubbles.forEach((bubble, i) => {
                bubble.position.copy(playerGroup.position);
                bubble.position.y = 0.5 + Math.sin(Date.now() * 0.002 + i) * 0.5;
                bubble.position.x += Math.cos(Date.now() * 0.002 + i) * 0.7;
                bubble.position.z += Math.sin(Date.now() * 0.002 + i) * 0.7;
            });

            updateUI();
        }

        function attack() {
            const damage = playerStats.specialActive ? playerStats.damage * 2 : playerStats.damage;
            const hitRange = playerStats.weaponTimer > 0 ? 4 : 3;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (playerGroup.position.distanceTo(enemy.position) < hitRange) {
                    enemy.hitsRemaining -= damage;
                    if (enemy.hitsRemaining <= 0) {
                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        playerStats.coins += Math.floor(Math.random() * 5) + 1;
                        playerStats.kills++;
                        if (playerStats.kills % 50 === 0) spawnEnemy('boss');
                        else if (playerStats.kills % 10 === 0) spawnEnemy('strong');
                        updateUI();
                    }
                }
            }
            if (playerStats.specialActive) {
                for (let i = portals.length - 1; i >= 0; i--) {
                    if (playerGroup.position.distanceTo(portals[i].position) < 3) {
                        scene.remove(portals[i]);
                        portals.splice(i, 1);
                    }
                }
            }
        }

        function updateEnemies() {
            if (isPaused) return;
            enemies.forEach(enemy => {
                const direction = playerGroup.position.clone().sub(enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(0.03));
                
                if (playerGroup.position.distanceTo(enemy.position) < 1) {
                    playerStats.health -= Math.max(1 - (playerStats.armorTimer > 0 ? playerStats.armor * 0.2 : playerStats.armor * 0.1), 0.1);
                    if (enemy.hitsRemaining > 1 && enemy.scale.x > 1.5) {
                        playerStats.stunTimer = 2;
                    }
                    updateUI();
                    if (playerStats.health <= 0) {
                        alert('Game Over! Score: ' + playerStats.kills);
                        resetGame();
                    }
                }
            });
        }

        function updateAllies() {
            if (isPaused) return;
            allies.forEach((ally, index) => {
                const nearestEnemy = enemies.reduce((closest, enemy) => {
                    const dist = ally.position.distanceTo(enemy.position);
                    return dist < closest.dist ? { enemy, dist } : closest;
                }, { enemy: null, dist: Infinity });
                
                if (nearestEnemy.enemy) {
                    const direction = nearestEnemy.enemy.position.clone().sub(ally.position).normalize();
                    ally.position.add(direction.multiplyScalar(0.08));
                    if (nearestEnemy.dist < 1) {
                        let damage = 1;
                        if (nearestEnemy.enemy.hitsRemaining > 1) { // Strong or Boss
                            damage = Math.min(nearestEnemy.enemy.hitsRemaining, Math.floor(nearestEnemy.enemy.hitsRemaining * 0.75));
                        }
                        nearestEnemy.enemy.hitsRemaining -= damage;
                        if (nearestEnemy.enemy.hitsRemaining <= 0) {
                            scene.remove(nearestEnemy.enemy);
                            enemies = enemies.filter(e => e !== nearestEnemy.enemy);
                        }
                    }
                }
                ally.timer -= 0.016;
                if (ally.timer <= 0) {
                    scene.remove(ally);
                    allies.splice(index, 1);
                }
            });
        }

        function buyUpgrade(type) {
            if (type === 'armor' && playerStats.coins >= 50 && playerStats.armorTimer <= 0) {
                playerStats.armorTimer = 17;
                playerStats.coins -= 50;
                for (let i = 0; i < 3; i++) createArmorBubble();
            } else if (type === 'health' && playerStats.coins >= 30) {
                playerStats.maxHealth += 20;
                playerStats.health = playerStats.maxHealth;
                playerStats.coins -= 30;
            } else if (type === 'speed' && playerStats.coins >= 40 && playerStats.speedTimer <= 0) {
                playerStats.speedTimer = 10;
                playerStats.coins -= 40;
            } else if (type === 'weapon' && playerStats.coins >= 60 && playerStats.weaponTimer <= 0) {
                playerStats.weaponTimer = 15;
                playerStats.damage = 3;
                sword.scale.set(1.5, 1.5, 1.5);
                playerStats.coins -= 60;
            } else if (type === 'ally' && playerStats.coins >= 10) {
                spawnAlly();
                playerStats.coins -= 10;
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('health').textContent = Math.floor(playerStats.health);
            document.getElementById('coins').textContent = playerStats.coins;
            document.getElementById('kills').textContent = playerStats.kills;
            document.getElementById('wave').textContent = wave;
            document.getElementById('special').textContent = 
                playerStats.specialActive ? `Active (${Math.ceil(playerStats.specialTimer)}s)` :
                playerStats.specialCooldown > 0 ? `Cooldown (${Math.ceil(playerStats.specialCooldown)}s)` : 'Ready (Q)';
        }

        function saveScore(score) {
            leaderboard.push(score);
            leaderboard.sort((a, b) => b - a);
            leaderboard = leaderboard.slice(0, 5);
            localStorage.setItem('cubeDefenseLeaderboard', JSON.stringify(leaderboard));
            updateLeaderboardUI();
        }

        function updateLeaderboardUI() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            leaderboard.forEach(score => {
                const li = document.createElement('li');
                li.textContent = score;
                list.appendChild(li);
            });
        }

        function spawnWave() {
            enemiesToSpawn = wave * 5;
            waveTimer = 10;
            wave++;
        }

        let spawnTimer = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) {
                updatePlayer();
                updateEnemies();
                updateAllies();

                if (enemiesToSpawn > 0 && spawnTimer <= 0 && portals.length > 0) {
                    spawnEnemy('normal');
                    enemiesToSpawn--;
                    spawnTimer = 0.5;
                }
                spawnTimer -= 0.016;

                waveTimer -= 0.016;
                if (waveTimer <= 0 && enemies.length === 0 && enemiesToSpawn === 0) {
                    spawnWave();
                }

                if (playerStats.weaponTimer <= 0 && playerStats.damage > 1) {
                    playerStats.damage = 1;
                    sword.scale.set(1, 1, 1);
                }
            }
            renderer.render(scene, camera);
        }

        createPortal();
        createPortal();
        spawnWave();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
