<!DOCTYPE html>
<html>
<head>
    <title>Cube Defense</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #shop {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            color: white;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Health: <span id="health">100</span></div>
        <div>Coins: <span id="coins">0</span></div>
        <div>Kills: <span id="kills">0</span></div>
        <div>Special: <span id="special">Ready (Q)</span></div>
    </div>
    <div id="shop">
        <h3>Shop</h3>
        <button onclick="buyUpgrade('armor')">Armor (50 coins)</button>
        <button onclick="buyUpgrade('health')">Health (30 coins)</button>
        <button onclick="buyUpgrade('speed')">Speed (40 coins)</button>
        <button onclick="buyUpgrade('weapon')">Weapon (60 coins)</button>
        <button onclick="buyUpgrade('ally')">Ally Cube (10 coins)</button>
    </div>
    <div id="pauseMenu">
        <h2>Paused</h2>
        <button onclick="resumeGame()">Resume</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Player setup with longer sword
        const playerGroup = new THREE.Group();
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        const swordGeometry = new THREE.BoxGeometry(0.2, 0.2, 2.5); // Longer sword
        const swordMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        const sword = new THREE.Mesh(swordGeometry, swordMaterial);
        sword.position.set(0.6, 0, 0.5); // Adjusted for longer sword
        playerGroup.add(player, sword);
        scene.add(playerGroup);
        camera.position.set(0, 10, 15);
        camera.lookAt(playerGroup.position);

        const groundGeometry = new THREE.PlaneGeometry(50, 30);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let playerStats = {
            health: 100,
            maxHealth: 100,
            coins: 0,
            kills: 0,
            speed: 0.15,
            damage: 3,
            armor: 0,
            attackCooldown: 0,
            specialCooldown: 0,
            specialActive: false,
            specialTimer: 0,
            stunTimer: 0
        };

        let enemies = [];
        let portals = [];
        let allies = [];
        const keys = {};
        let isPaused = false;

        function resetGame() {
            playerStats.health = playerStats.maxHealth;
            playerStats.stunTimer = 0;
            playerGroup.position.set(0, 0.5, 0);
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            portals.forEach(portal => scene.remove(portal));
            portals = [];
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            createPortal();
            updateUI();
        }

        function createPortal() {
            const portalGeometry = new THREE.CylinderGeometry(2, 2, 0.2, 32);
            const portalMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(
                (Math.random() - 0.5) * 45,
                0.1,
                (Math.random() - 0.5) * 25
            );
            scene.add(portal);
            portals.push(portal);
        }

        function spawnEnemy(type = 'normal') {
            if (portals.length === 0) return;
            const portal = portals[Math.floor(Math.random() * portals.length)];
            
            let size, color, hits;
            if (type === 'strong') {
                size = 1.5;
                color = 0x0000ff; // Blue
                hits = 10;
            } else if (type === 'boss') {
                size = 2;
                color = 0x800080; // Purple
                hits = 25;
            } else {
                size = 1;
                color = 0xff0000; // Red
                hits = 1;
            }

            const enemyGeometry = new THREE.BoxGeometry(size, size, size);
            const enemyMaterial = new THREE.MeshBasicMaterial({ color });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.hitsRemaining = hits;
            enemy.position.copy(portal.position);
            enemy.position.y = size / 2;

            if (type === 'boss') {
                const crownGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
                const crownMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.y = size / 2 + 0.15;
                enemy.add(crown);
            }

            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnAlly() {
            const allyGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const allyMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const ally = new THREE.Mesh(allyGeometry, allyMaterial);
            ally.position.copy(playerGroup.position);
            ally.health = 50;
            scene.add(ally);
            allies.push(ally);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') togglePause();
            if (e.key === 'q' && playerStats.specialCooldown <= 0) activateSpecial();
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseMenu').style.display = isPaused ? 'block' : 'none';
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
        }

        function activateSpecial() {
            playerStats.specialActive = true;
            playerStats.specialTimer = 4;
            playerStats.specialCooldown = 20;
            updateUI();
        }

        function updatePlayer() {
            if (isPaused || playerStats.stunTimer > 0) return;

            let currentSpeed = playerStats.specialActive ? playerStats.speed * 2 : playerStats.speed;
            if (keys['ArrowUp']) playerGroup.position.z -= currentSpeed;
            if (keys['ArrowDown']) playerGroup.position.z += currentSpeed;
            if (keys['ArrowLeft']) playerGroup.position.x -= currentSpeed;
            if (keys['ArrowRight']) playerGroup.position.x += currentSpeed;

            playerGroup.position.x = Math.max(-24, Math.min(24, playerGroup.position.x));
            playerGroup.position.z = Math.max(-14, Math.min(14, playerGroup.position.z));

            if (keys[' '] && playerStats.attackCooldown <= 0) {
                attack();
                playerStats.attackCooldown = 0.5;
                sword.rotation.x = Math.PI / 4;
            }
            sword.rotation.x *= 0.9;

            playerStats.attackCooldown -= 0.016;
            if (playerStats.specialActive) {
                playerStats.specialTimer -= 0.016;
                if (playerStats.specialTimer <= 0) playerStats.specialActive = false;
            }
            playerStats.specialCooldown -= 0.016;
            playerStats.stunTimer = Math.max(0, playerStats.stunTimer - 0.016);
            updateUI();
        }

        function attack() {
            const damage = playerStats.specialActive ? playerStats.damage * 2 : playerStats.damage;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (playerGroup.position.distanceTo(enemy.position) < 3) { // Larger hitbox
                    enemy.hitsRemaining--;
                    if (enemy.hitsRemaining <= 0) {
                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        playerStats.coins += Math.floor(Math.random() * 5) + 1;
                        playerStats.kills++;
                        if (playerStats.kills % 50 === 0) spawnEnemy('boss');
                        else if (playerStats.kills % 10 === 0) spawnEnemy('strong');
                        updateUI();
                    }
                }
            }
            if (playerStats.specialActive) {
                for (let i = portals.length - 1; i >= 0; i--) {
                    if (playerGroup.position.distanceTo(portals[i].position) < 3) {
                        scene.remove(portals[i]);
                        portals.splice(i, 1);
                    }
                }
            }
        }

        function updateEnemies() {
            if (isPaused) return;
            enemies.forEach(enemy => {
                const direction = playerGroup.position.clone().sub(enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(0.03));
                
                if (playerGroup.position.distanceTo(enemy.position) < 1) {
                    playerStats.health -= Math.max(1 - playerStats.armor * 0.1, 0.1);
                    if (enemy.hitsRemaining > 1 && enemy.scale.x > 1.5) { // Boss stun
                        playerStats.stunTimer = 2;
                    }
                    updateUI();
                    if (playerStats.health <= 0) {
                        alert('Game Over! Score: ' + playerStats.kills);
                        resetGame();
                    }
                }
            });
        }

        function updateAllies() {
            if (isPaused) return;
            allies.forEach((ally, index) => {
                const nearestEnemy = enemies.reduce((closest, enemy) => {
                    const dist = ally.position.distanceTo(enemy.position);
                    return dist < closest.dist ? { enemy, dist } : closest;
                }, { enemy: null, dist: Infinity });
                
                if (nearestEnemy.enemy) {
                    const direction = nearestEnemy.enemy.position.clone().sub(ally.position).normalize();
                    ally.position.add(direction.multiplyScalar(0.08));
                    if (nearestEnemy.dist < 1) {
                        nearestEnemy.enemy.hitsRemaining--;
                        if (nearestEnemy.enemy.hitsRemaining <= 0) {
                            scene.remove(nearestEnemy.enemy);
                            enemies = enemies.filter(e => e !== nearestEnemy.enemy);
                        }
                    }
                }
                ally.health -= 0.1;
                if (ally.health <= 0) {
                    scene.remove(ally);
                    allies.splice(index, 1);
                }
            });
        }

        function buyUpgrade(type) {
            if (type === 'armor' && playerStats.coins >= 50) {
                playerStats.armor++;
                playerStats.coins -= 50;
            } else if (type === 'health' && playerStats.coins >= 30) {
                playerStats.maxHealth += 20;
                playerStats.health = playerStats.maxHealth;
                playerStats.coins -= 30;
            } else if (type === 'speed' && playerStats.coins >= 40) {
                playerStats.speed += 0.02;
                playerStats.coins -= 40;
            } else if (type === 'weapon' && playerStats.coins >= 60) {
                playerStats.damage += 2;
                playerStats.coins -= 60;
            } else if (type === 'ally' && playerStats.coins >= 10) {
                spawnAlly();
                playerStats.coins -= 10;
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('health').textContent = Math.floor(playerStats.health);
            document.getElementById('coins').textContent = playerStats.coins;
            document.getElementById('kills').textContent = playerStats.kills;
            document.getElementById('special').textContent = 
                playerStats.specialActive ? `Active (${Math.ceil(playerStats.specialTimer)}s)` :
                playerStats.specialCooldown > 0 ? `Cooldown (${Math.ceil(playerStats.specialCooldown)}s)` : 'Ready (Q)';
        }

        let spawnTimer = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) {
                updatePlayer();
                updateEnemies();
                updateAllies();

                spawnTimer += 0.016;
                if (spawnTimer > 2 && portals.length > 0) {
                    spawnEnemy('normal');
                    spawnTimer = 0;
                }
            }
            renderer.render(scene, camera);
        }

        createPortal();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
