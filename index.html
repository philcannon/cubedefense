<!DOCTYPE html>
<html>
<head>
    <title>Cube Defense</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #shop {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
        }
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            color: white;
            display: none;
            text-align: center;
        }
        #leaderboard {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
        }
        #pauseButton {
            position: absolute;
            top: 110px;
            left: 10px;
            padding: 5px 10px;
        }
        #levelDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 48px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui"></div>
    <div id="shop"></div>
    <div id="pauseMenu">
        <h2>Paused</h2>
        <button onclick="resumeGame()">Resume</button>
    </div>
    <div id="leaderboard">
        <h3>Top Scores</h3>
        <ol id="leaderboardList"></ol>
    </div>
    <div id="pauseButton"></div>
    <div id="levelDisplay">Level 1</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/@playcanvas/pcui@1.2.1/dist/pcui.js"></script>
    <script src="https://unpkg.com/@playcanvas/observer@1.2.1/dist/observer.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@playcanvas/pcui@1.2.1/dist/pcui.css">

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Player setup
        const playerGroup = new THREE.Group();
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00,
            shininess: 100,
            specular: 0xffffff
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        const swordGeometry = new THREE.BoxGeometry(0.2, 0.2, 2.5);
        const swordMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xaaaaaa,
            shininess: 50,
            specular: 0xffffff
        });
        const sword = new THREE.Mesh(swordGeometry, swordMaterial);
        sword.position.set(0.6, 0, 0.5);
        playerGroup.add(player, sword);
        scene.add(playerGroup);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        scene.background = new THREE.Color(0x87ceeb);
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(-20, 20, 20);
        scene.add(sun);
        for (let i = 0; i < 5; i++) {
            const cloudGeometry = new THREE.SphereGeometry(2, 16, 16);
            const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(
                (Math.random() - 0.5) * 40,
                15 + Math.random() * 5,
                (Math.random() - 0.5) * 20
            );
            cloud.scale.set(1 + Math.random(), 0.5 + Math.random() * 0.5, 1 + Math.random());
            scene.add(cloud);
        }

        const groundGeometry = new THREE.PlaneGeometry(50, 30);
        const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x90ee90 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let playerStats = {
            health: 100,
            maxHealth: 100,
            coins: 0,
            kills: 0,
            baseSpeed: 0.15,
            speed: 0.15,
            damage: 1,
            armor: 0,
            attackCooldown: 0,
            specialCooldown: 0,
            specialActive: false,
            specialTimer: 0,
            stunTimer: 0,
            speedTimer: 0,
            armorTimer: 0,
            weaponTimer: 0
        };

        let enemies = [];
        let portals = [];
        let allies = [];
        let coins = [];
        let trailParticles = [];
        let armorBubbles = [];
        const keys = {};
        let isPaused = false;
        let wave = 1;
        let waveTimer = 0;
        let enemiesToSpawn = 0;

        let leaderboard = JSON.parse(localStorage.getItem('cubeDefenseLeaderboard')) || [];
        updateLeaderboardUI();

        // PCUI Setup
        const observer = new Observer(playerStats);

        const uiContainer = document.getElementById('ui');
        const healthLabel = new pcui.Label({ text: 'Health: 100' });
        const coinsLabel = new pcui.Label({ text: 'Coins: 0' });
        const killsLabel = new pcui.Label({ text: 'Kills: 0' });
        const waveLabel = new pcui.Label({ text: 'Wave: 1' });
        const specialLabel = new pcui.Label({ text: 'Special: Ready (Q)' });

        healthLabel.binding = new pcui.BindingObserversToElement();
        healthLabel.link(observer, 'health', (value) => `Health: ${Math.floor(value)}`);
        coinsLabel.binding = new pcui.BindingObserversToElement();
        coinsLabel.link(observer, 'coins', (value) => `Coins: ${value}`);
        killsLabel.binding = new pcui.BindingObserversToElement();
        killsLabel.link(observer, 'kills', (value) => `Kills: ${value}`);
        waveLabel.binding = new pcui.BindingObserversToElement();
        waveLabel.link(observer, 'wave', (value) => `Wave: ${value}`);
        specialLabel.binding = new pcui.BindingObserversToElement();
        specialLabel.link(observer, ['specialActive', 'specialTimer', 'specialCooldown'], 
            (active, timer, cooldown) => active ? `Active (${Math.ceil(timer)}s)` : 
            cooldown > 0 ? `Cooldown (${Math.ceil(cooldown)}s)` : 'Ready (Q)');

        uiContainer.appendChild(healthLabel.dom);
        uiContainer.appendChild(coinsLabel.dom);
        uiContainer.appendChild(killsLabel.dom);
        uiContainer.appendChild(waveLabel.dom);
        uiContainer.appendChild(specialLabel.dom);

        const shopContainer = document.getElementById('shop');
        const shopTitle = new pcui.Label({ text: 'Shop' });
        shopTitle.class.add('pcui-label-header');
        shopContainer.appendChild(shopTitle.dom);

        const upgrades = [
            { type: 'armor', cost: 50, text: 'Armor (50 coins)' },
            { type: 'health', cost: 30, text: 'Health (30 coins)' },
            { type: 'speed', cost: 40, text: 'Speed (40 coins)' },
            { type: 'weapon', cost: 60, text: 'Weapon (60 coins)' },
            { type: 'ally', cost: 30, text: 'Ally Cube (30 coins)' }
        ];

        upgrades.forEach(upgrade => {
            const button = new pcui.Button({
                text: upgrade.text,
                enabled: observer.get('coins') >= upgrade.cost
            });
            button.on('click', () => buyUpgrade(upgrade.type));
            shopContainer.appendChild(button.dom);
            observer.on('coins:change', (value) => {
                button.enabled = value >= upgrade.cost;
            });
        });

        const pauseButton = new pcui.Button({ text: 'Pause' });
        pauseButton.on('click', togglePause);
        document.getElementById('pauseButton').appendChild(pauseButton.dom);

        function showLevelDisplay() {
            const levelDisplay = document.getElementById('levelDisplay');
            levelDisplay.style.display = 'block';
            setTimeout(() => {
                levelDisplay.style.display = 'none';
            }, 2000);
        }

        function resetGame() {
            saveScore(playerStats.kills);
            Object.assign(playerStats, {
                health: playerStats.maxHealth,
                stunTimer: 0,
                coins: 0,
                kills: 0,
                wave: 1
            });
            observer.set(playerStats);
            playerGroup.position.set(0, 0.5, 0);
            enemies.forEach(enemy => scene.remove(enemy.mesh || enemy));
            enemies = [];
            portals.forEach(portal => scene.remove(portal));
            portals = [];
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            coins.forEach(coin => scene.remove(coin));
            coins = [];
            trailParticles.forEach(p => scene.remove(p));
            trailParticles = [];
            armorBubbles.forEach(b => scene.remove(b));
            armorBubbles = [];
            createPortal();
            createPortal();
            updateUI();
            spawnWave();
            showLevelDisplay();
        }

        function createPortal(type = 'normal') {
            const portalGeometry = new THREE.CylinderGeometry(2, 2, 0.2, 32);
            const portalMaterial = new THREE.MeshPhongMaterial({ 
                color: type === 'boss' ? 0x800080 : 0xff0000, 
                shininess: 30 
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(
                (Math.random() - 0.5) * 45,
                0.1,
                (Math.random() - 0.5) * 25
            );
            portal.type = type;
            scene.add(portal);
            portals.push(portal);
        }

        function spawnEnemy(type = 'normal', fromBoss = false) {
            const portal = fromBoss ? 
                portals.find(p => p.type === 'boss') || portals[Math.floor(Math.random() * portals.length)] :
                portals[Math.floor(Math.random() * portals.length)];
            if (!portal) return;

            let size, color, hits, speed, damage;
            if (type === 'strong') {
                size = 1.5;
                color = 0x0000ff;
                hits = 7;
                speed = 0.03;
                damage = 1;
            } else if (type === 'boss') {
                size = 2;
                color = 0x800080;
                hits = 25;
                speed = 0.03;
                damage = 2;
            } else if (type === 'minion') {
                size = 0.7;
                color = 0x800080;
                hits = 5;
                speed = 0.04;
                damage = 0.5;
            } else if (type === 'fast') {
                size = 0.8;
                color = 0x87cefa;
                hits = 3;
                speed = 0.08;
                damage = 0.3;
            } else {
                size = 1;
                color = 0xff0000;
                hits = 1;
                speed = 0.03;
                damage = 1;
            }

            const enemyGroup = new THREE.Group();
            const enemyGeometry = new THREE.BoxGeometry(size, size, size);
            const enemyMaterial = new THREE.MeshPhongMaterial({ 
                color,
                shininess: 100,
                specular: 0xffffff
            });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemyGroup.add(enemy);

            if (type === 'boss') {
                const bossSwordGeometry = new THREE.BoxGeometry(0.2, 0.2, 2.5);
                const bossSwordMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, shininess: 50 });
                const bossSword = new THREE.Mesh(bossSwordGeometry, bossSwordMaterial);
                bossSword.position.set(0.6, 0, 0.5);
                enemyGroup.add(bossSword);
                enemyGroup.sword = bossSword;
                enemyGroup.attackCooldown = 0;
                enemyGroup.summonCooldown = 0;
                enemyGroup.shockwaveCooldown = 0;

                const crownGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
                const crownMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 50 });
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.y = size / 2 + 0.15;
                enemyGroup.add(crown);
            }

            if (type !== 'normal') {
                const healthBarBg = new THREE.Mesh(
                    new THREE.PlaneGeometry(size, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0x666666 })
                );
                const healthBar = new THREE.Mesh(
                    new THREE.PlaneGeometry(size, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                healthBarBg.position.set(0, size / 2 + 0.2, 0);
                healthBar.position.set(0, size / 2 + 0.2, 0);
                enemyGroup.add(healthBarBg, healthBar);
                enemyGroup.healthBar = healthBar;
                enemyGroup.healthBarBg = healthBarBg;
            }

            enemyGroup.hitsRemaining = hits;
            enemyGroup.maxHits = hits;
            enemyGroup.speed = speed;
            enemyGroup.damage = damage;
            enemyGroup.type = type;
            enemyGroup.position.copy(portal.position);
            enemyGroup.position.y = size / 2;
            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        function spawnAlly() {
            const allyGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const allyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0000ff,
                shininess: 100,
                specular: 0xffffff
            });
            const ally = new THREE.Mesh(allyGeometry, allyMaterial);
            ally.position.copy(playerGroup.position);
            ally.timer = 7;

            const healthBarBg = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x666666 })
            );
            const healthBar = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 0.1),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            healthBarBg.position.set(0, 0.5, 0);
            healthBar.position.set(0, 0.5, 0);
            ally.add(healthBarBg, healthBar);
            ally.healthBar = healthBar;
            ally.healthBarBg = healthBarBg;
            ally.maxTimer = 7;

            scene.add(ally);
            allies.push(ally);
        }

        function spawnCoin(position) {
            const coinGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
            const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 50 });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.copy(position);
            coin.position.y = 0.05;
            coin.value = Math.floor(Math.random() * 5) + 1;
            scene.add(coin);
            coins.push(coin);
        }

        function createTrailParticle() {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.copy(playerGroup.position);
            particle.position.y = 0.5;
            scene.add(particle);
            trailParticles.push({ mesh: particle, life: 0.5 });
        }

        function createArmorBubble() {
            const bubbleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const bubbleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.5,
                shininess: 50
            });
            const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
            scene.add(bubble);
            armorBubbles.push(bubble);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') togglePause();
            if (e.key === 'q' && playerStats.specialCooldown <= 0) activateSpecial();
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseMenu').style.display = isPaused ? 'block' : 'none';
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
        }

        function activateSpecial() {
            playerStats.specialActive = true;
            playerStats.specialTimer = 4;
            playerStats.specialCooldown = 20;
            observer.set('specialActive', true);
            observer.set('specialTimer', 4);
            observer.set('specialCooldown', 20);
            updateUI();
        }

        function updatePlayer() {
            if (isPaused || playerStats.stunTimer > 0) return;

            camera.position.set(playerGroup.position.x, 10, playerGroup.position.z + 15);
            camera.lookAt(playerGroup.position);

            let currentSpeed = playerStats.specialActive ? playerStats.baseSpeed * 2 : playerStats.speed;
            if (keys['ArrowUp']) playerGroup.position.z -= currentSpeed;
            if (keys['ArrowDown']) playerGroup.position.z += currentSpeed;
            if (keys['ArrowLeft']) playerGroup.position.x -= currentSpeed;
            if (keys['ArrowRight']) playerGroup.position.x += currentSpeed;

            playerGroup.position.x = Math.max(-24, Math.min(24, playerGroup.position.x));
            playerGroup.position.z = Math.max(-14, Math.min(14, playerGroup.position.z));

            if (keys[' '] && playerStats.attackCooldown <= 0) {
                attack();
                playerStats.attackCooldown = 0.5;
                sword.rotation.x = Math.PI / 4;
            }
            sword.rotation.x *= 0.9;

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                if (playerGroup.position.distanceTo(coin.position) < 1) {
                    playerStats.coins += coin.value;
                    observer.set('coins', playerStats.coins);
                    scene.remove(coin);
                    coins.splice(i, 1);
                }
            }

            playerStats.attackCooldown -= 0.016;
            playerStats.speedTimer = Math.max(0, playerStats.speedTimer - 0.016);
            playerStats.armorTimer = Math.max(0, playerStats.armorTimer - 0.016);
            playerStats.weaponTimer = Math.max(0, playerStats.weaponTimer - 0.016);
            if (playerStats.speedTimer > 0) {
                playerStats.speed = playerStats.baseSpeed * 2;
                if (Math.random() < 0.3) createTrailParticle();
            } else {
                playerStats.speed = playerStats.baseSpeed;
            }
            if (playerStats.armorTimer <= 0 && armorBubbles.length > 0) {
                armorBubbles.forEach(b => scene.remove(b));
                armorBubbles = [];
            }
            if (playerStats.specialActive) {
                playerStats.specialTimer -= 0.016;
                observer.set('specialTimer', playerStats.specialTimer);
                if (playerStats.specialTimer <= 0) {
                    playerStats.specialActive = false;
                    observer.set('specialActive', false);
                }
            }
            playerStats.specialCooldown -= 0.016;
            observer.set('specialCooldown', playerStats.specialCooldown);
            playerStats.stunTimer = Math.max(0, playerStats.stunTimer - 0.016);

            for (let i = trailParticles.length - 1; i >= 0; i--) {
                trailParticles[i].life -= 0.016;
                trailParticles[i].mesh.scale.multiplyScalar(0.95);
                if (trailParticles[i].life <= 0) {
                    scene.remove(trailParticles[i].mesh);
                    trailParticles.splice(i, 1);
                }
            }

            armorBubbles.forEach((bubble, i) => {
                bubble.position.copy(playerGroup.position);
                bubble.position.y = 0.5 + Math.sin(Date.now() * 0.002 + i) * 0.5;
                bubble.position.x += Math.cos(Date.now() * 0.002 + i) * 0.7;
                bubble.position.z += Math.sin(Date.now() * 0.002 + i) * 0.7;
            });

            observer.set('health', playerStats.health);
        }

        function attack() {
            const damage = playerStats.specialActive ? playerStats.damage * 2 : playerStats.damage;
            const hitRange = playerStats.weaponTimer > 0 ? 4 : 3;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (playerGroup.position.distanceTo(enemy.position) < hitRange) {
                    enemy.hitsRemaining -= damage;
                    if (enemy.healthBar) {
                        enemy.healthBar.scale.x = enemy.hitsRemaining / enemy.maxHits;
                        enemy.healthBar.position.x = -enemy.scale.x / 2 + (enemy.scale.x * enemy.healthBar.scale.x) / 2;
                    }
                    if (enemy.hitsRemaining <= 0) {
                        spawnCoin(enemy.position);
                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        playerStats.kills++;
                        observer.set('kills', playerStats.kills);
                        if (wave >= 5 && playerStats.kills % 50 === 0) {
                            createPortal('boss');
                            spawnEnemy('boss');
                        } else if (playerStats.kills % 10 === 0) spawnEnemy('strong');
                    }
                }
            }
            if (playerStats.specialActive) {
                for (let i = portals.length - 1; i >= 0; i--) {
                    if (playerGroup.position.distanceTo(portals[i].position) < 3) {
                        scene.remove(portals[i]);
                        portals.splice(i, 1);
                    }
                }
            }
        }

        function updateEnemies() {
            if (isPaused) return;
            enemies.forEach(enemy => {
                const direction = playerGroup.position.clone().sub(enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(enemy.speed));
                
                if (enemy.type === 'boss') {
                    enemy.attackCooldown -= 0.016;
                    enemy.summonCooldown -= 0.016;
                    enemy.shockwaveCooldown -= 0.016;

                    if (enemy.attackCooldown <= 0) {
                        enemy.sword.rotation.x = Math.PI / 4;
                        if (playerGroup.position.distanceTo(enemy.position) < 3) {
                            playerStats.health -= enemy.damage;
                            observer.set('health', playerStats.health);
                        }
                        enemy.attackCooldown = 0.5;
                    }
                    enemy.sword.rotation.x *= 0.9;

                    if (enemy.summonCooldown <= 0) {
                        for (let i = 0; i < 3; i++) spawnEnemy('minion', true);
                        enemy.summonCooldown = 20;
                    }

                    if (enemy.shockwaveCooldown <= 0 && playerGroup.position.distanceTo(enemy.position) < 5) {
                        playerStats.stunTimer = 2;
                        enemy.shockwaveCooldown = 10;
                    }
                }

                if (playerGroup.position.distanceTo(enemy.position) < 1) {
                    playerStats.health -= Math.max(enemy.damage - (playerStats.armorTimer > 0 ? playerStats.armor * 0.2 : playerStats.armor * 0.1), 0.1);
                    observer.set('health', playerStats.health);
                    if (enemy.type === 'boss') {
                        playerStats.stunTimer = 2;
                    }
                    if (playerStats.health <= 0) {
                        alert('Game Over! Score: ' + playerStats.kills);
                        resetGame();
                    }
                }
            });
        }

        function updateAllies() {
            if (isPaused) return;
            allies.forEach((ally, index) => {
                const nearestEnemy = enemies.reduce((closest, enemy) => {
                    const dist = ally.position.distanceTo(enemy.position);
                    return dist < closest.dist ? { enemy, dist } : closest;
                }, { enemy: null, dist: Infinity });
                
                if (nearestEnemy.enemy) {
                    const direction = nearestEnemy.enemy.position.clone().sub(ally.position).normalize();
                    ally.position.add(direction.multiplyScalar(0.08));
                    if (nearestEnemy.dist < 1) {
                        let damage = 1;
                        if (nearestEnemy.enemy.hitsRemaining > 1) {
                            damage = Math.min(nearestEnemy.enemy.hitsRemaining, Math.floor(nearestEnemy.enemy.hitsRemaining * 0.75));
                        }
                        nearestEnemy.enemy.hitsRemaining -= damage;
                        if (nearestEnemy.enemy.healthBar) {
                            nearestEnemy.enemy.healthBar.scale.x = nearestEnemy.enemy.hitsRemaining / nearestEnemy.enemy.maxHits;
                            nearestEnemy.enemy.healthBar.position.x = -nearestEnemy.enemy.scale.x / 2 + (nearestEnemy.enemy.scale.x * nearestEnemy.enemy.healthBar.scale.x) / 2;
                        }
                        if (nearestEnemy.enemy.hitsRemaining <= 0) {
                            spawnCoin(nearestEnemy.enemy.position);
                            scene.remove(nearestEnemy.enemy);
                            enemies = enemies.filter(e => e !== nearestEnemy.enemy);
                        }
                    }
                }
                ally.timer -= 0.016;
                ally.healthBar.scale.x = ally.timer / ally.maxTimer;
                ally.healthBar.position.x = -0.4 + (0.8 * ally.healthBar.scale.x) / 2;
                if (ally.timer <= 0) {
                    scene.remove(ally);
                    allies.splice(index, 1);
                }
            });
        }

        function buyUpgrade(type) {
            if (type === 'armor' && playerStats.coins >= 50 && playerStats.armorTimer <= 0) {
                playerStats.armorTimer = 17;
                playerStats.coins -= 50;
                observer.set('coins', playerStats.coins);
                for (let i = 0; i < 3; i++) createArmorBubble();
            } else if (type === 'health' && playerStats.coins >= 30) {
                playerStats.maxHealth += 20;
                playerStats.health = playerStats.maxHealth;
                observer.set('health', playerStats.health);
                observer.set('maxHealth', playerStats.maxHealth);
                playerStats.coins -= 30;
                observer.set('coins', playerStats.coins);
            } else if (type === 'speed' && playerStats.coins >= 40 && playerStats.speedTimer <= 0) {
                playerStats.speedTimer = 10;
                playerStats.coins -= 40;
                observer.set('coins', playerStats.coins);
            } else if (type === 'weapon' && playerStats.coins >= 60 && playerStats.weaponTimer <= 0) {
                playerStats.weaponTimer = 15;
                playerStats.damage = 3;
                sword.scale.set(1.5, 1.5, 1.5);
                playerStats.coins -= 60;
                observer.set('coins', playerStats.coins);
            } else if (type === 'ally' && playerStats.coins >= 30) {
                spawnAlly();
                playerStats.coins -= 30;
                observer.set('coins', playerStats.coins);
            }
        }

        function saveScore(score) {
            leaderboard.push(score);
            leaderboard.sort((a, b) => b - a);
            leaderboard = leaderboard.slice(0, 5);
            localStorage.setItem('cubeDefenseLeaderboard', JSON.stringify(leaderboard));
            updateLeaderboardUI();
        }

        function updateLeaderboardUI() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            leaderboard.forEach(score => {
                const li = document.createElement('li');
                li.textContent = score;
                list.appendChild(li);
            });
        }

        function spawnWave() {
            enemiesToSpawn = wave * 5;
            if (wave % 2 === 0) spawnEnemy('fast');
            if (wave === 5) {
                createPortal('boss');
                spawnEnemy('boss');
            }
            waveTimer = 10;
            wave++;
            playerStats.wave = wave;
            observer.set('wave', wave);
            document.getElementById('levelDisplay').textContent = `Level ${wave - 1}`;
            showLevelDisplay();
        }

        let spawnTimer = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) {
                updatePlayer();
                updateEnemies();
                updateAllies();

                if (enemiesToSpawn > 0 && spawnTimer <= 0 && portals.length > 0) {
                    spawnEnemy('normal');
                    enemiesToSpawn--;
                    spawnTimer = 0.5;
                }
                spawnTimer -= 0.016;

                waveTimer -= 0.016;
                if (waveTimer <= 0 && enemies.length === 0 && enemiesToSpawn === 0) {
                    spawnWave();
                }

                if (playerStats.weaponTimer <= 0 && playerStats.damage > 1) {
                    playerStats.damage = 1;
                    sword.scale.set(1, 1, 1);
                }
            }
            renderer.render(scene, camera);
        }

        createPortal();
        createPortal();
        spawnWave();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
